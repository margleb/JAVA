/*
 * ВЛОЖЕННЫЕ КЛАССЫ:
 * 
 * Вложенные классы (Nested classes) - это классы которые определены внутри других классов
 * 
 * Вложенные классы делятся на две категории
 *  - статические (static) называются как "статические вложенные классы" (static nested classes)
 *  - не статические классы называются "внутренние классы" (inner classes)
 * 
 * Вложенные классы являются членами включающих их классов.
 * 
 * Нестатические вложенные классы (inner classes) имеют доступ к другим членам включающего класса,даже если они объявлены приватными
 * Статические вложенные классы не имеют доступа к другим членам включающего класса.
 * 
 * Вложенные классы могут быть обьявлены как private, public, protected, or package private
 * (Напомним, что внешние классы могут быть объявлены только как public или package private)
 * 
 * Зачем использовать вложенные классы?
 * - Это логические способ группировки классов, которые используются только в одном месте
 * - Это позволяет увеличить инкапсуляцию. Вложенный класс спрятан от "внешнего мира" и имеет доступ до членов включающего его класса 
 * - Это позволяет сделать код более читаемым, а также упростить его поддержку
 * 
 * Статические вложенные классы
 * Как и с методами и переменными, cтатический класс связан с его внешним классом, 
 * Как и с статическими методами класса, статический вложенный класс не может напрямую ссылаться на переменные экземпляра или методы, определенные в включающем его классе
 * Он может использовать их только через ссылку на обьект
 * 
 * Статический вложенный класс взаимодействует с членами экземпляра его внешнего класса (и других классов), как и любой другой класс верхнего уровня.
 * По сути, статический вложенный класс является поведенческим классом верхнего уровня, который был вложен в другой класс верхнего уровня для удобства упаковки.
 * 
 * Доступ к статическим вложенным классам осуществляется с помощью имени включающего класса:
 * OuterClass.StaticNestedClass
 * Например, чтобы создать объект для статического вложенного класса, используйте этот синтаксис:
 * OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
 * 
 * Внутренние классы
 * Как и в случае методов и переменных экземпляра, внутренний класс связан с экземпляром включающего его класса и имеет прямой доступ к методам и полям этого объекта.
 * Кроме того, поскольку внутренний класс связан с экземпляром, он не может сам определять статические члены.
 * Пример:
 * class OuterClass {
 *    ...
 *   class InnerClass {
 *       ...
 *   }
 * }
 * 
 * Чтобы создать экземпляр внутреннего класса, вы должны сначала создать экземпляр внешнего класса. 
 * Затем создайте внутренний объект во внешнем объекте с этим синтаксисом:
 * OuterClass.InnerClass innerObject = outerObject.new InnerClass();
 * 
 * Существует два специальных вида внутренних классов: 
 * - локальные классы(local class) 
 * - анонимные классы(anonymous classes)
 * 
 * Если объявление типа (такого как переменная-член или имя параметра) в определенной области (например, внутренний класс или определение метода) имеет то же имя, 
 * что и другое объявление во вмещающей его области, тогда объявление затеняет (shadows) декларацию охватывающей области
 * (смотри образец кода "затенение")
 * 
 * СЕРИАЛИЗАЦИЯ
 * Сериализация внутренних классов, включая локальные и анонимные классы, настоятельно не рекомендуется.
 * Когда компилятор Java компилирует определенные конструкции, такие как внутренние классы, он создает синтетические конструкции (synthetic constructs).
 * синтетические конструкции - это классы, методы, поля и другие конструкции, которые не имеют соответствующей конструкции в исходном коде
 * 
 * ВНУТРЕННИЕ КЛАССЫ
 * 
 * Итераторы используются для пошагового прохождения структуры данных и, 
 * как правило, имеют методы для проверки послед
 * него элемента, 
 * извлечения текущего элемента и перехода к следующему элементу.
 * 
 * Вы можете использовать внутренние классы для реализации вспомогательных классов.
 * Для обработки событий пользовательского интерфейса вы должны знать, 
 * как использовать внутренние классы, потому что механизм обработки событий широко использует их.
 * 
 * Локальные и анонимные классы
 * Есть два дополнительных типа внутренних классов
 * Вы можете объявить внутренний класс в теле метода. Эти классы известны как локальные классы (local classes)
 * Вы также можете объявить внутренний класс в теле метода без указания имени класса. 
 * Эти классы известны как анонимные классы (anonymous classes).
 * 
 * МОДИФИКАТОРЫ
 * Для внутренних классов вы можете использовать те же модификаторы, что и для других членов внешнего класса. 
 * Например, вы можете использовать модификаторы доступа private, public и protected для ограничения доступа
 * к внутреннему классу
 * 
 * 
*/ 

/*
 * ОТРЫВКИ КОДА
 * 
 * 1. Пример затенения перерменной x
 *    - Создаем класс ShadowTest
 *      - создаем int переменную x равную 0
 *      - создаем внутренний класс FirstLevel
 *         - создаем int переменную x равную 1
 *         - создаем void метод с параметро x
 *           - выводим в консоль аргумент метода x
 *           - выводим в консоль через this значение поля класса FirtstLavel
 *           - выводим значение поля класса ShadowTest через this
 *     - В main методе
 *       - инициализируем класс ShadowTest();
 *       - инициализируем вложенный класс FirstLevel
 *       - инициализируем мето methodInFirstLevel с аргументом 23
 * 
 * 2. Пример внтуреннего класса
 *    - Создаем класс DataStructure
 *    - Создаем свой-ва
 *      - приватное финальное статическое свойство типа int SIZE приравненное 15
 *      - приватный массив типа int arrayOfInts , с зарезервированной памятию на SIZE элементов
 *    - Создаем конструктор без аргументов
 *      - циклом for перебираем константу SIZE и заносим в значение arrayOfInts
 *      
 *    - Создаем пустой интерфейс DataStructureIterator, расширяемых библиотекой java.util.Iterator<Integer>
 *    - Cоздаем класс EvenIterator импломентирующий интерфей DataStructureIterator
 *      - приватное поле int nextIndex равное 0 // проход по шагам с самого начала
 *      - публичный метод типа boolean hasNext()
 *        - возращает проверку, если текущий элемент последний в массиве
 *      - публичный метод next c типом данных Integer
 *        - запись значения (retValue) четного индекса массива (Integer.valueOf)
 *        - получение следующего четного элемента
 *          - инекремент nextIndex на 2
 *          - возращение returnValue
 *          
 *    - Cоздаем void метод printEven()
 *        - создаем экз. класса EvenIterator
 *        - циклом whilе проверяем есть ли следующий элемент 
 *          - если есть выводим в консоль 
 *              
 *    - В осн. методе main 
 *      - Создаем экземпляр класса new DataStructure()
 *      - Инифциализируем printEven()

 */



public class DataStructure {
	
	private static final int SIZE = 15;
	private int[] arrayOfInts = new int[SIZE];
	
	DataStructure() {
		for (int i = 0; i < SIZE; i++) {
			arrayOfInts[i] = i;
		}
	}
	
	interface DataStructureIterator extends java.util.Iterator<Integer> { } 
	
	class EvenIterator  implements DataStructureIterator {
		// проход по шагам с самого начала
		private int nextIndex = 0;
		
		public boolean hasNext() {
			return (nextIndex <= SIZE - 1);
		}
		
		public Integer next() {
			// запись значения (retValue) четного индекса массива 
			Integer retValue = Integer.valueOf(arrayOfInts[nextIndex]);
			// получить следующий четный элемент
			nextIndex += 2;
			return retValue;
		}
		
	};
	
	public void printEven() {
		EvenIterator even = this.new EvenIterator();
		while(even.hasNext()) {
			System.out.print(even.next() + " ");
		}
		System.out.println();
	}
	
	public static void main(String[] args) {
		DataStructure structure = new DataStructure();
		structure.printEven();		
	}

}