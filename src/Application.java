/*
 * 
 * ОБЬЯВЛЕНИЕ КЛАССОВ
 * 
 * Обьявление класса (class declaration) - написание шаблона класса
 * Суперкласс (superclass) (родительский класс) - называют класс , на основе которого создаются другие классы.
 * Cобкласс (subclass) - дочерний класс
 * 
 * Обьявления класса могут содержать следующие компоненты:
 *  - Модификаторы такие как public, private и т.д.
 *  - Название класса (всегда с большой буквы)
 *  - Имя родительского класса (суперкласса), предшествующее ключевому слову extends. 
 *    Дочерний класс может быть расширен только одним родительским классом
 *  - Список имполментированых интерфейсов, предшествующие ключевому слову implements. 
 *    Может быть имполментировано более одного интерфейса
 *  - Тело класса, окруженного фигурными скобками {}
 * 
 * ОБЬЯВЛЕНИЕ ПЕРЕМЕННЫХ-ЧЛЕНОВ
 * 
 * Существует несколько типов переменныx:
 *  - Переменные-члены в классе - они называются полями (fields)
 *  - Переменные в методе или блоке кода - они называются локальными переменными (lосal variables).
 *  - Переменные в объявлениях методов - они называются параметрами (parameters).
 * 
 * Обьявление полей состоит из трех компоненотов:
 *  - Нулевового или более модификаторов, таких как public или private
 *  - Типа поля (int, String и т.д.)
 *  - Имени поля
 *  
 * Модификаторы доступа
 * В целях инкапсуляции принято делать поля приватными, а для получения доступа к ним использовать публичные методы
 * 
 * Типы
 * Каждая переменная обязана иметь тип. Можно использовать примитивные типы (primitive type: int, float, boolean и т.д.),
 * или ссылочные (reference type: string, arrays, objects и т.д.)
 * 
 * Имена переменных
 * Все переменные, будь то поля, локальные переменные или параметры, следуют тем же правилам и соглашениям об именах, которые были рассмотрены в уроке Основы языка, Переменные - Именование.
 * Для имен методов и классов используются одни и те же правила и соглашения об именах, за исключением того, что:
 *  - первая буква имени класса должна быть заглавной
 *  - первое (или единственное) слово в имени метода должно быть глаголом.

 * ОПРЕДЕЛЕНИЕ МЕТОДА
 * В более общем смысле, объявления методов имеют шесть компонентов в порядке:
 * 1. Модификаторы - такие как public/protected и т.д.
 * 2. Тип возврата (return type) - тип данных значения, возвращаемого методом, или void, если метод не возвращает значение.
 * 3. Имя метода
 * 4. Список параметров в скобках
 * 5. Cписок исключений (exception list)
 * 6. Тело метода, заключенное в фигурные скобки
 * 
 * Два компонента обьявления метода (имя методоа и типы параметров) называются сигнатурой метода (method singature)
 * Например:
 * calculateAnswer(double, int, double, double)
 * 
 * Именование методов
 * По соглашению имена методов должны быть глаголом в нижнем регистре или именем из нескольких слов, которое начинается с глагола в нижнем регистре, за которым следуют прилагательные, существительные и т. д
 * первая буква каждого из второго и следующих слов должна быть написана заглавными буквами
 * Например:
 * run, runFast, getBackground, getFinalData, compareTo, setX, isEmpty
 * 
 * Как правило, метод имеет уникальное имя в своем классе. Однако метод может иметь то же имя, что и другие методы, из-за перегрузки метода (method overloading).
 * Компилятор не учитывает тип возвращаемого значения при различении методов, поэтому вы не можете объявить два метода с одинаковой сигнатурой, даже если они имеют другой тип возвращаемого значения.
 * Перегруженные методы следует использовать с осторожностью, поскольку они могут сделать код гораздо менее читабельным.
 * 
 * КОНСТРУКТОРЫ
 * Классы могут содержать конструкторы, которые вызываются при создании обьектов.
 * 
 * Объявления конструктора выглядят как объявления методов, за исключением того, что они используют имя класса и НЕ ИМЕЮТ возвращаемого типа.
 * Классы могут содержать несколько конструторов, включая конструктор без аргументов (no-argumet)
 * Как и в случае с методами, платформа Java различает конструкторы по количеству аргументов в списке и их типам.
 * 
 * Компилятор автоматически предоставляет конструктор по умолчанию без аргументов для любого класса без конструкторов, называемы конструктор суперкласса без аргументов (no-argument constructor of the superclass)
 * Если у вашего класса нет явного суперкласса, то у него есть неявный суперкласс Object, у которого есть конструктор без аргументов.
 * 
 * Вы можете использовать конструктор суперкласса самостоятельно, например указав в конструторе:
 * public MountainBike(int startHeight, int startCadence, int startSpeed, int startGear) {
 *    super(startCadence, startSpeed, startGear); // суперкласс
 *    seatHeight = startHeight;
 * }   
 * 
 * Вы можете использовать модификаторы доступа в объявлении конструктора, чтобы контролировать, какие другие классы могут вызывать конструктор.
 * Если другой класс не может вызвать конструктор MyClass, он НЕ МОЖЕТ напрямую создавать объекты MyClass.
 * 
 * ПЕРЕДАЧА ИНФОРМАЦИИ В МЕТОД ИЛИ КОНСТРУКТОР
 * Параметры (parameters) ссылаются на список переменных в объявлении метода. Аргументы (arguments) - это фактические значения, которые передаются при вызове метода.
 * Когда вы вызываете метод, используемые аргументы должны соответствовать параметрам объявления в типе и порядке.
 * 
 * Типы параметров
 * Допускается любой тип параметоров для метода или конструктора. 
 * Можно использовать как примитивные типы данных (primitive data), такие как doubles, floats, integers и т.д.
 * Такие и ссылочные типы (такие как обьекты и массивы)
 * 
 * Если вы хотите передать метод в метод, используйте лямбда-выражение (lambda expression) или ссылку на метод (method reference).
 * 
 * Произвольное количество аргументов
 * Вы можете использовать конструкцию varargs для передачи произвольного числа значений в метод
 * Вы используете varargs, когда не знаете, сколько аргументов определенного типа будет передано методу.
 * Это сокращенный вариант создания массива вручную
 * 
 * Чтобы использовать varargs, тип параметра следует за многоточием (три точки, ...), затем пробелом и именем параметра.
 * Пример:
 * polygonFrom(Point... corners)
 * 
 * Метод может быть вызван с любым номером этого параметра, включая ни одного.
 * 
 * Имена параметров
 * Имя параметра должно быть уникальным в своей области
 * 
 * Параметр может иметь то же имя, что и одно из полей класса. Если это так, говорят, что параметр затеняет поле (shadow the field).
 * Затенение полей может затруднить чтение вашего кода и обычно используется только внутри конструкторов и методов, которые устанавливают определенное поле
 * 
 * Передача аргументов примитивного типа данных
 * Примитивные аргументы, такие как int или double, передаются в методы по значению. 
 * Это означает, что любые изменения значений параметров существуют только в рамках метода.
 * Когда метод возвращается, параметры исчезают и любые изменения в них теряются
 * 
 * Передача аргументов типа ссылочных данных
 * Параметры ссылочного типа, такие как объекты, также передаются в методы по значению. 
 * Это означает, что при возврате метода переданная ссылка все еще ссылается на тот же объект, что и раньше.
 * Однако значения полей объекта МОГУТ БЫТЬ ИЗМЕНЕНЫ в методе, если они имеют надлежащий уровень доступа.
 * 
 * 
 */


/* ПРИМЕРЫ КОДОВ
 * 
 * 1. Передача аргументов примитивного типа данных
 *    - создаем метод принимающий в качестве аргумента переменную типа int и изменяющий ее значение
 *    - в методе main обьявляем локальную переменнюу int, вызываем метод и выводим в консоль значение переменной 
 *    (ее значение не изменилось)
 *
 * 2. Передача аргументов типа ссылочных данных
 *    - создаем класс Сircle,
 *      - c полями x, y;
 *      - конструктор для полей
 *    	- методами get/set для полей
 *    - в основном классе создаем метод movieСircle();
 *      - в качестве аргументов передаем обьект класса circle, а также две int переменные
 *      - вызываем методы set обьекта с передачей параметров в них (текущее значение + увеличение)
 *      - создаем экземпляр класса Сircle с нулевыми аргументами полей x/y, приравниваем к переданному 
 *        аргументу circle
 *    - инициализируем метод moveCircle() в методе main;
 * 
 * 3. Пример использования конструтора суперкласса
 *    - создаем класс Bycicle
 *    	- в качестве полей указываем int переменные
 *      	- cadence
 *      	- gear
 *      	- speed
 *    	- создаем конструктор для полей (с модификатором public)
 *    	- два метода set для сandence и gear
 *    	- для метода для speed (инкремент/декремент поля)
 *    
 *    - создаем родительский класс MountainBike (extends)
 *      - cоздаем одно поле для него seatHeight
 *      - создаем конструктор для поля + полей из суперкласса
 *        - используем метод super()
 *      - создаем метод set для поля height   
 */



public class Application {
	
	// #1
	// public static void passMethod(int p) {
		// p = 10;
	// }
	
	// #2
	static void movieCircle(Circle c, int shiftX, int shiftY) {		
		// устанавливаем новые значения
		c.setX(c.getX() + shiftX);
		c.setY(c.getY() + shiftY);
		// новый экземпляр класса
		c =  new Circle(0, 0);
	}
	
	public static void main(String... args) {
		
		// #1
		// int x = 3;	
		// passMethod(x)
		// значения не изменились
		// System.out.println("After invoking passMethod, x = " + x);
		
		// #2
		Circle circle = new Circle(40, 50);
		movieCircle(circle, 2, 3);
		// значения изменились
		System.out.println(circle.getX());
		System.out.println(circle.getY());
		
	}
	
}
