/*
 * CПРАВКА
 * Eсли реализация анонимного класса очень проста, например, интерфейс, который содержит только один метод, то синтаксис анонимных классов может показаться громоздким и неясным
 * Лямбда-выражения позволяют более компактно выражать экземпляры классов с одним методом.
 * 
 * 
 * ЛЯМБДА-ВЫРАЖЕНИЯ В ПРИЛОЖЕНИЯХ С ГРАФИЧЕСКИМ ИНТЕРФЕЙСОМ
 * Для обработки событий в приложении с графическим пользовательским интерфейсом, таких как действия клавиатуры, мыши и прокрутки, 
 * вы обычно создаете обработчики событий, которые обычно включают реализацию определенного интерфейса.
 * Часто интерфейсы обработчика событий являются функциональными интерфейсами; у них, как правило, есть только один метод.
 * Для этих целей можно использовать лямбда-выражения
 * 
 * СИНТАКСИС ЛЯМБДА ВЫРАЖЕНИЙ
 * Лямбда-выражение состоит из следующего:
 * 
 * 1. Разделенный запятыми список формальных параметров, заключенный в скобки
 * Примечание: вы можете опустить тип данных параметров в лямбда-выражении. Кроме того, вы можете опустить скобки, если есть только один параметр.
 * 
 * Например, следующее лямба-выражение будет также валидно:
 * p -> p.getGender() == Person.Sex.MALE 
 *  && p.getAge() >= 18
 *  && p.getAge() <= 25
 *    
 * 2. Токен стрелка ->
 * 
 * 3. Тело, состоящее из одного выражения или блока операторов. В этом примере используется следующее выражение:
 * p.getGender() == Person.Sex.MALE
 *  && p.getAge() >= 18
 *  && p.getAge() <= 25
 *  
 * 4. Тело, состоящее из одного выражения или блока операторов. В этом примере используется следующее выражение:
 * p.getGender() == Person.Sex.MALE
 *  && p.getAge() >= 18
 *  && p.getAge() <= 25  
 *  
 * Если вы укажете одно выражение, тогда среда выполнения Java оценивает выражение и затем возвращает его значение. 
 * В качестве альтернативы вы можете использовать оператор возврата:
 * p -> {
 * return p.getGender() == Person.Sex.MALE
 *      && p.getAge() >= 18
 *      && p.getAge() <= 25;
 * }
 * 
 * Оператор возврата не является выражением; в лямбда-выражении вы должны заключать выражения в фигурные скобки ({}).
 * Однако вам не нужно заключать вызов метода void в фигурные скобки. Например, следующее является допустимым лямбда-выражением:
 * email -> System.out.println(email)
 * 
 * Обратите внимание, что лямбда-выражение очень похоже на объявление метода; Вы можете рассматривать лямбда-выражения как анонимные методы - методы без имени.
 * 
 * ДОСТУП К ЛОКАЛЬНЫМ ПЕРЕМЕННЫМ ОКРУЖАЮЩЕЙ ОБЛАСТИ ВИДИМОСТИ
 * Как и локальные и анонимные классы, лямбда-выражения могут захватывать переменные, они имеют одинаковый доступ к локальным переменным окружения
 * днако, в отличие от локальных и анонимных классов, у лямбда-выражений нет проблем с теневым копированием
 * 
 * Лямбда-выражения лексически ограничены - это означает, что они не наследуют никаких имен от супертипа или вводят новый уровень видимости.
 * Объявления в лямбда-выражении интерпретируются так же, как и во внешней среде. 
 * 
 * Лямбда-выражение не вводит новый уровень видимости. Следовательно, вы можете получить прямой доступ к полям, методам и локальным переменным окружения
 * 
 * Подобно локальным и анонимным классам, лямбда-выражение может обращаться только к локальным переменным и параметрам заключающего блока, 
 * которые являются окончательными или эффективно окончательными
 * 
 * ЦЕЛЕВЫЕ ТИПЫ
 * Чтобы определить тип лямбда-выражения, компилятор Java использует целевой тип контекста или ситуации, в которой было найдено лямбда-выражение.
 * 
 * Отсюда следует, что вы можете использовать лямбда-выражения только в ситуациях, когда компилятор Java может определить целевой тип:
 * - Объявления переменных
 * - Назначения
 * - Возращаемого statement
 * - Инициализации массивов
 * - Аргументы метода или конструктора
 * - Лямбда-выражения тела
 * - Условные выражения ?:
 * - Cast выражения
 * 
 * Типы целей и аргументы методов
 * Для аргументов метода компилятор Java определяет целевой тип с двумя другими языковыми функциями:
 * - overload resolution
 * - type argument inference
 * 
 * Сериализация
 * Вы можете сериализовать лямбда-выражение, если его целевой тип и захваченные аргументы сериализуемы. 
 * Однако, как и внутренние классы, сериализация лямбда-выражений настоятельно не рекомендуется.
 * 
 */
