/*
 * ВОЗРАТ ЗНАЧЕНИЯ ИЗ МЕТОДА
 * Метод возвращает код, который его вызвал, когда:
 *  - завершает все утверждения в методе
 *  - достигает оператора возврата или бросает исключение (throws an exception)
 * 
 * Возращаемый тип метода указывается в обьявлении метода.
 * В теле метода для возрата значения используется оператор return
 * 
 * Любой объявленный метод void не возвращает значение. 
 * Он не должен содержать оператор return, однако его использование допускается при необходимости выхода из метода.
 * В таком случае он просто используется как return (без указания возращаемого значения).
 * При попытки возрата значения из метода, который обьявлен как void, я получу ошибку компилятора
 * 
 * Любой метод, который не объявлен как void, 
 * должен содержать утверждения return с соответствующим возвращаемым значением, 
 * например так:
 * return returnValue;
 * 
 * Тип данных возвращаемого значения должен соответствовать объявленному типу возврата метода
 * 
 * ВОЗРАЩЕНИЕ КЛАССА ИЛИ ИНТЕРФЕЙСА
 * Ecли метод использует имя класса в качестве возращаемого типа, 
 * то тип возращаемого обьекта должен быть либо собклассом, 
 * либо тем же самым классом возращаемого обьекта
 * 
 * Этот метод, называемый ковариантным типом возврата (covariant return type), означает, 
 * что тип возвращаемого значения может изменяться в том же направлении, что и подкласс.
 * 
 * Вы также можете использовать имена интерфейсов в качестве типов возврата. 
 * В этом случае возвращаемый объект должен реализовывать указанный интерфейс.
 * 
 * ИСПОЛЬЗОВАНИЕ КЛЮЧЕВОГО СЛОВА THIS
 * В экземпляре метода или конструктора this осначает ссылка на текущий объект - объект, чей метод или конструктор вызывается.
 * Используя this, вы можете ссылаться на любой член текущего объекта из метода экземпляра или конструктора.
 * 
 * Самая распространенная причина использования этого ключевого слова заключается в том, что поле затеняется (shadowed) параметром метода или конструктора.
 * Пример:
 * public class Point {
 *	    public int x = 0;
 *	    public int y = 0;
 *       
 *   //constructor
 *	    public Point(int x, int y) {
 *	        this.x = x;
 *	        this.y = y;
 *	  }
 * }
 * 
 * ИСПОЛЬЗОВАНИЕ THIS C КОНСТРУКТОРОМ
 * Внутри конструктора вы также можете использовать ключевое слово this для вызова другого конструктора в том же классе.
 * Это называется явным вызовом конструктора (explicit constructor invocation)
 * Пример:
 * public Rectangle() {
 *    this(0, 0, 1, 1);
 * }
 * 
 *  Вызов другого конструктора внутри должен быть первой строкой в ​​конструкторе.
 *  
 *  УПРАВЛЕНИЕ ДОСТУПОМ К ЧЛЕНАМ КЛАССА
 *  Модификаторы уровня доступа определяют, могут ли другие классы использовать конкретное поле или вызывать определенный метод. 
 *  
 *  Существует два уровня контроля доступа:
 *  
 *  1. На верхнем уровне (top-level) - public или package-private (без явного модификатора).
 *     1.1 public - этом случае этот класс виден всем классам везде
 *     1.2 package-private - если класс не имеет явного модификатора, то он виден только в своем собственном пакете
 *     
 *  2. На уровне члена-участника (member level) - public, private, protected или package-private (без явного модификатора).
 *     2.1 private - члены могу иметь доступ только в собственном классе
 *     2.2 protected - к члену можно получить доступ только в его собственном пакете (как с package-private), или в подкассе данного класса в другом пакете
 *     2.3 public и private-package имеют тот же смысл, что и для классов верхнего уровня 
 *     
 *  Советы по выбору уровня доступа:
 *  1. Используйте наиболее ограниченный уровень доступа, если у вас нет веских причин не делать этого.   
 *  2. Избегайте открытых полей, кроме констант. 
 *  
 *  ПОНИМАНИЕ ЧЛЕНОВ КЛАССА
 *  
 *  Переменные класса
 *  При создании обьектов из шаблона класса, каждый из них имеет собственный копию экземпляра переменной (instance variables)
 *  C помочью модификатора static можно создать общую переменную для всех обьектов, ассоциируемую с классом, а не с обьектом. 
 *  Поле имеющее модификтор static в своем обьявлении, называется статическим полем (static fields) или классовой перменной (class variables)
 *  
 *  Переменную класса можно изменять не создавая ее экземпляра, также любой обьект может изменить значение переменной класса
 *  
 *  Для получения доступа к классовой перменной используется конструкия:
 *  СlassName.numberOfBicycles
 *  
 *  К классовой переменной (статическому полю) можно также сослаться через обьект, например:
 *  instanceName.numberOfBicycles
 *  Однако такую конструкцию использовать нежелательно, так как она не дает четкого понимания что это классовая переменная
 *  
 *  Методы класса
 *  Язык программирования Java поддерживает статические методы, а также статические переменные.
 *  Статические методы, которые имеют модификатор static в своих объявлениях, 
 *  должны вызываться с именем класса, без необходимости создания экземпляра класса
 *  Например:
 *  ClassName.methodName(args)
 *  
 *  Вы также можете ссылаться на статические методы с помощью ссылки на объект, например:
 *  instanceName.methodName(args)
 *  но это не рекомендуется, потому что это не дает понять, что они являются классовыми методами.
 *  
 *  Обычное использование статических методов - доступ к статическим полям.
 *  
 *  Разрешены не все комбинации переменных и методов экземпляра и класса:
 *  - Методы экземпляра могут напрямую обращаться к переменным экземпляра и методам экземпляра.
 *  - Методы экземпляра могут напрямую обращаться к переменным класса и методам класса.
 *  - Классовые методы могут обращаться к переменным класса и методам класса напрямую.
 *  - Классовые методы НЕ МОГУТ получить доступ к переменным экземпляра или методам экземпляра напрямую
 *    они должны использовать ссылку на объект. Кроме того, классовые методы не могут использовать ключевое слово this, 
 *    так как для них нет экземпляра класса
 *  
 *  Константы
 *  Модификатор static в сочетании с модификатором final также используется для определения констант. 
 *  модификатор final указывает, что значение этого поля не может измениться.
 *  
 *  Определенные таким образом константы не могут быть переназначены
 *  По соглашению имена постоянных значений пишутся заглавными буквами.
 *  Если имя состоит из более чем одного слова, слова разделяются подчеркиванием (_).
 *  
 *  Если примитивный тип или строка определены как константа и ее значение известно во время компиляции, 
 *  компилятор заменяет имя константы везде в коде на его значение.Это называется константой времени компиляции (compile-time constant).
 *  В случае изменения константы, требуется перекомпилировать любой класс, где используется данная конста для получения текущего значения
 *  
 *  ИНИЦИАЛИЗАЦИЯ ПОЛЕЙ
 *  
 *  Допускается указание начального значения для поля в его объявлении:
 *  public class BedAndBreakfast {
 *    // initialize to 10
 *    public static int capacity = 10;

 *    // initialize to false
 *    private boolean full = false;
 * 	}
 * 
 *  Если для инициализации требуется некоторая логика, просто назначение не является подходящим вариантом
 *  Для обеспечения такой возможности, в языка JAVA включает в себя статические инициализационные блоки 
 *  (static initialization blocks)
 *  
 *  Нет необходимости объявлять поля в начале определения класса, хотя это наиболее распространенная практика.
 *  Необходимо только, чтобы они были объявлены и инициализированы перед использованием.
 *  
 *  Статические блоки инициализации
 *  Блок статической инициализации - это обычный блок кода, заключенный в фигурные скобки {} и перед которым стоит ключевое слово static. 
 *  Например:
 *  static {
 *   // любой код, необходимый для инициализации, идет сюда
 *	}
 *  
 *  Класс может иметь любое количество статических блоков инициализации, и они могут появляться в любом месте тела класса.
 *  Есть альтернатива статическим блокам - вы можете написать приватный статический метод:
 *  class Whatever {
 *	    public static varType myVar = initializeClassVariable();        
 *	    private static varType initializeClassVariable() {
 *	        // initialization code goes here
 *	    }
 *	}
 *
 *  Преимущество закрытых статических методов заключается в том, что они могут быть повторно использованы позже, 
 *  если вам нужно повторно инициализировать переменную класса.
 *  
 *  Инициализация членов экземпляра
 *  Обычно для инциализации переменной экземпляра используется конструктор
 *  Существует две альтернативы использованию конструктора для инициализации переменных экземпляра: 
 *  блоки инициализатора (initializer blocks) и финальные методы (final methods).
 *  
 *  Блоки инициализатора для переменных экземпляра выглядят так же, как статические блоки инициализатора, но без ключевого слова static:
 *  {
 *   // любой код, необходимый для инициализации, идет сюда
 *	}
 *  Компилятор Java копирует блоки инициализатора в каждый конструктор. Следовательно, этот подход можно использовать для разделения блока кода между несколькими конструкторами.
 *  
 *  финальный метод не может быть переопределен в подклассе. 
 *  Пример использования финального метода для инициализации переменной экземпляра:
 *  class Whatever {
 *   	private varType myVar = initializeInstanceVariable();
 *   	protected final varType initializeInstanceVariable() {
 *       	// код инициализации идет сжа
 *   	}
 *	}
 *  
 *  Это особенно полезно, если подклассы могут захотеть повторно использовать метод инициализации
 *  Метод является финальным, потому что вызов не финальных методов во время инициализации экземпляра может вызвать проблемы.
 *  
 */

/*
 * ОТРЫВКИ КОДА
 * 1. Используем ключевое слово this для полей
 *    - В коде из секции Objects, у класса Point в конструторое заменяем у полей x/y ключевым словом this
 * 2. Используем ключевое слово this c конструктором
 *    - В коде из секции Objects, у конструторов там где нужно заменяем ключевым словом this
 *    
 *3. Классовые Переменные
 *   - В коде из секции Classes, для класса Вycicle добавляем добавляем:
 *     - экземпляр переменной для обьекта с его id
 *     - добавляем приватное статическое св-во для подсчета кол-во велосипедов
 *     - добавляем инкремент в конструктор Bicyclе для подсчета кол-во велосипедов
 *     - добавляем метод для возращения текущего id обьекта
 */

public class Application {
	public static void main(String[] args) {
		System.out.println("More on Classes");
	}
}