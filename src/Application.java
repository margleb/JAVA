/*
 * ЛОКАЛЬНЫЕ КЛАССЫ
 * 
 * Локальные классы - это классы, которые определены в блоке кода, c нулем или более количеством утверждений (statement),
 * заключенные в фигурные скобки. Обычно локальные классы определены, в теле метода.
 * 
 * Объявление локальных классов
 * Вы можете определить локальный класс в любом блоке, например в теле метода, цикле for или в условии if
 * 
 * Доступ к членам вмещающего класса
 * Локальные классы имеют доступ до членов включающего их классов, а также к локальным переменным.
 * Однако, локальные классы могут иметь доступ до локальных переменных только ОБЬЯВЛЕННЫХ КАК ФИАНАЛЬНЫЕ (final),
 * такие переменные называются захваченными переменными (captured variable).
 * 
 * Начиная с JAVS SE 8, локальные классы могут иметь доступ до локальных переменных и параметров включаемого блока
 * если они финальные или эффективно финальные (effectively final)
 * 
 * Переменная или параметр, значение которых никогда не изменяется после инициализации, 
 * является эффективно финальным (effectively final).
 * 
 * Начиная с Java SE 8, если вы объявляете локальный класс в методе, он может получить доступ к параметрам метода.
 * 
 * Затенение и Локальные классы
 * Обьявленные переменные в локальном классе затеняют (shadowing) переменные вложенной области видимости, 
 * если они имеют с ними схожее название
 * 
 * Локальные классы похожи на внутренние классы
 * потому что они не могут определять или объявлять какие-либо статические члены.
 * Локальные классы в статических методах,  могут ссылаться только на статические члены включающего класса.
 * 
 * Локальные классы не являются статичными, потому что они имеют доступ к членам экземпляра вмещающего блока.
 * Следовательно, они не могут содержать большинство видов статических объявлений.
 * 
 * Вы не можете объявить интерфейс внутри блока; интерфейсы по своей природе статичны
 * 
 * Локальный класс может иметь статические члены при условии, что они являются ПОСТОЯННЫМИ ПЕРЕМЕННЫМИ.
 * Постоянная перменная (constant variable) - это переменная примитивного типа или типа String, 
 * которая обьявлена как final и инициавлизирована с помошью константного выражения во время компиляции
 * 
 * 
 * 
 */


/*
 * ОТРЫВКИ КОДА
 * 
 * 1. Пример обьявления локального класса
 *    - создаем статическое поле regularExpression со значение "[0-9]";
 *    - создаем void метод validatePhoneNumber c аргументами типа String phoneNumber1, phoneNumber2
 *      - cоздаем финальную локальную переменную int numberLength cо значением 10
 *      // указываем также что для JDK8 и позже допускается указание переменной без ключ.слова final
 *      - cоздаем класс PhoneNumber
 *        - Cоздаем переменную типа String formattedPhoneNumber cо значение null
 *        - Cоздаем конструктор PhoneNumber c параметром типа String phoneNumber
 *          // пробуем изменить переменную numberLenght, для того, чтобы убедиться что будет ошибка
 *          - создаем переменнюу типа String currentNumber c заменой phoneNumber по регулярному выражению (метод replaceAll())
 *          - Если длина текщущего номера(currentNumber.length()), равна длине поля numberLength
 *            - присвоить currentNumber к formattedPhoneNumber
 *           - иначе присвоить к значению null
 *      - Cоздаем getNumber() метод возращающий formattedPhoneNumber
 *      // Действителен в JDK 8 и более поздних версиях (закоментировано):
 *      - Создаем void метод printOriginalNumbers
 *        - выводит оригинатльные номера phoneNumber1  и phoneNumber2
 *    - Cоздаем экземпляры классов PhoneNumber: myNumber1/myNumber2
 *    // Действителен в JDK 8 и более поздних версиях (закоментировано):
 *    -  инициализируем метод printOriginalNumbers()
 *    - если номер равен null
 *      - выводим "номер не валиден"
 *    - иначе
 *      - выводим "номер равен " + номер
 *    - В main методе инициализируем метод validatePhoneNumber, с передачей аргументов
 *    
 *2. Пример невожможности обьявления интерфейса внутри блока, по причине его статичности
 *	 // 1ый пример
 *   - создаем метод greetInEnglish
 *     - обьявляем интерфейс HelloThere с методом void greet()
 *     - создаем класс EnglishHelloThere импломентирующий интерфейс HelloThere 
 *       - пробуем перезаписать метод и вывести сообщение "Hello + " + name
 *     - инициализируем класс EnglishHelloThere
 *     - пробуем вызовать метод geet(), получаем ошибку
 *   // 2ой пример
 *   - создаем void метод sayGoodbyeInEnglish
 *     - внутри создаем локальный класс EnglishGoodbye 
 *       - создаем СТАТИЧНЫЙ void метод sayGoodbye()
 *         - выводим в консоль какое то текст
 *     - пробуем инициализировать метод, получаем ошибку так как в локальном классе статический метод!
 *  // 3ий пример: 
 *     - обьявляем постоянную перменную внутри класса типа String farewell и приравниваем ее к "Bye Bye"
 *     - убираем static у метода sayGoodbye()
 *       - выводим в консоль farewell
 *     - пробуем инициализировать метод sayGoodbye(), ошибки нет, как farewell - постоянная переменная
 *    
 */



public class Application {
	
	// public void greetInEnglish() {
		// Нельзя обьявлять интерфейс внутри блока
		// Интерфейсы по своей природе статичны
        // interface HelloThere {
           // public void greet();
        // }
        // class EnglishHelloThere implements HelloThere {
            // public void greet() {
                // System.out.println("Hello " + name);
            // }
        // }
        // HelloThere myGreeting = new EnglishHelloThere();
        // myGreeting.greet();
    // }
	
	
	// public void sayGoodbyeInEnglish() {
        // class EnglishGoodbye {
        	// Вы не можете объявлять статические инициализаторы  в локальном классе.
            // public static void sayGoodbye() {
                // System.out.println("Bye bye");
            // }
        // }
        // EnglishGoodbye.sayGoodbye();
    // }
	
	
	 // public void sayGoodbyeInEnglish() {
	        // class EnglishGoodbye {
	        	// Локальный класс может иметь статические члены при условии, 
	        	// что они являются постоянными переменными
	            // public static final String farewell = "Bye bye";
	            // public void sayGoodbye() {
	                // System.out.println(farewell);
	            // }
	        // }
	        // EnglishGoodbye myEnglishGoodbye = new EnglishGoodbye();
	        // myEnglishGoodbye.sayGoodbye();
	// }
	
	public static void main(String[] args) {
		
	}
}
